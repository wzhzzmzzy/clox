# Chaptor 25: Closures

这一章主要实现的内容：
- 支持闭包，可以在嵌套声明的函数中引用外部变量；
- 将所有的函数（`ObjFunction`）调用修改为闭包（`ObjClosure`）调用；
- 编译函数内的变量时，提升其引用到的外层局部变量（`upvalue`）；

## 变量提升

在 24 章和之前，我们实现的局部变量是存储于堆栈区的，以 stack 的形式管理生命周期。在调用函数时，通过 CallFrame 中的 slot 属性创建滑动窗口来访问函数执行期间创建的局部变量。

闭包中，我们可以在嵌套函数里使用外层函数内创建的变量，还可以将嵌套函数返回出去。这就需要脱离生命周期来访问局部变量，所以需要做变量提升。这一章的主要工作就是实现变量提升。

### 构建`compiler.upvalues`

在编译期，我们需要在创建函数时，将会被引用到的局部变量标记为需要提升。在 24 章中，我们给每个函数都添加了一个单独的 Compiler 实例，在`locals`中存储创建的局部变量。在 25 章，我们添加了`upvalues`，用于存储被提升的外部变量引用。为了构建跨层级的变量提升，创建`upvalues`时，递归向上搜索所有的层级，保证每一层都保存了完整的`upvalue`链条。

### 将变量迁移到 heap

函数执行结束或是离开变量作用域（`block`）时，会调用`endScope()`，清理生命周期结束的所有局部变量。此时，我们需要将被提升的局部变量从 stack 迁移到 heap，保证它依然能够被访问。同时，我们需要多个指向同一个`local`的`upvalue`能够复用同一个指针。

这里我们创建一个`vm.openUpvalue`链表，并且使其保持降序排列，每次提升变量时，先查询链表中是否已经存在相同的指针。

为了提高性能，减少内存占用，我们在尽量晚的时间迁移`local`到 heap 中。需要迁移时，compiler 会发出一条`OP_CLOSE_UPVALUE`指令，让 VM 修改所有 `upvalue` 状态，因为此时所有的局部变量都需要被迁移到 heap。略微不同的是，`OP_RETURN` 只会修改当前 CallFrame 中的所有局部变量。



