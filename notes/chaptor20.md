## Chaptor 20: Hash Tables

这一章主要实现的内容：
- 基于 `ObjString*` 的 Hash 表实现方法，使用了叫做 FNV-1a 的哈希方法
    - KV 对查找和插入、修改逻辑
    - 删除、墓碑机制
    - 自动扩容和 Hash 重排
- 通过 Hash 表，实现了 VM 上的 `string intend` 功能，用于记录整个程序执行的周期内，创建的所有字符串，保证所有字符串都会被重用，不会重复创建。

### 注意

这里的 Hash Table 并不是作为语言功能存在的，只是作为一个基础设施，用于支持其他的语言功能，例如 `string intend` 等。他使用了 `ObjString*` 来存储 key 值，但本身并不是一个 `Obj`，也就是用户（目前）并不能直接在语言中创建一个 Hash Table 来存储数据。

### KV 对增删查，和自动扩容

这里的 Hash Table 实现，其实就是一个存储 `Entry`，也就是 KV 对的动态数组。`Entry` 如何组织是这里的重点。当插入一个新的数据时，会根据 Key 的 Hash % (当前 Table 的容量) 来计算将数据索引。这里我们设定，如果当前 Table 内的 KV 数量占总量的比例已经到达了某个值（`TABLE_MAX_LOAD`），就会触发扩容。

由于 `Entry` 的索引和容量有关，所以扩容时，我们需要对整个 Table 内的所有数据重新简历索引。可想而知，扩容是比较耗费性能的一个操作。

每当创建一个 `string` 的时候，我们就计算它的 Hash，缓存下来。获取到索引之后，如果索引重复了怎么办呢？这里使用的策略是索引直接 +1，这样能够尽量填满整个 Table。

匹配 `string` 时，我们会先使用 `hash` 匹配，避免每次都需要遍历 cstring，`hash` 重复时再遍历比较，找到最终与指定 key 匹配的 Entry。不然的话就是没有找到，返回 NULL。

#### Hash 算法

FNV-1a 算法的逻辑非常简单，如下：

```c
static uint32_t hashString(const char* key, int length) {
  uint32_t hash = 2166136261u;
  for (int i = 0; i < length; i++) {
    hash ^= (uint8_t)key[i];
    hash *= 16777619;
  }
  return hash;
}
```

### 删除操作

删除时如果直接将 `Entry` 置空，会影响到后续的数据索引。所以我们这里将 Key 置空，保证它并不会匹配到任何数据，但保留 Value，让它能够被识别，这种机制被称为【墓碑机制】。像是删除之后，在原地留下了一座墓碑。

对于这种情况，我们匹配数据时，就需要识别当前找到的是不是已删除的 `Entry`。如果是已经删除的，就缓存下来。如果最终找到了匹配的 `Entry`，就返回；如果找不到，进入了空值，就返回墓碑位置，保证它能够及时被数据重新覆盖。

我们不会希望整个 Table 里充满了已经被删除数据的占位符，但如果占位符被清理，会导致数据无法正常被索引，所以两权相害取其轻，我们选择了墓碑机制作为删除的方案。当扩容时，所有的墓碑会被清理，因为重排时会跳过这部分数据，只重排真实存在的 `Entry`。

### `string intern`

创建了 Hash Table，我们得把它利用起来。这里我们利用 Hash Table 实现 `string intern` 功能。它的主要目标是减少字符串字面量的内存占用，不希望每次创建一个相同的字符串都占用一份新的内存。

具体的实现方式是：我们在创建字符串时，会先去 `vm.string` 这个哈希表当中查找一遍，如果没有找到匹配的数据，就新增一个条目；如果找到了，就直接返回这个字符串的 `ObjString*`，保证相同的字符串都会被重用。

这里我们还加速了字符串比较的速度。如果我们使用 == 比较字符串，完全可以直接使用 == 来比较两个对象，因为相同的字符串必然会使用同一个指针。

在常见的通用程序语言当中，不一定是所有的字符串都会经历 intern 这个过程。有些语言会提供一个专门的 `Symbol` 类型，这种类型会被 intern，但字符串不会。

可以看到，这里的哈希表利用时，我们只关注 Key 的匹配情况，并不关注其 Value 是什么。所以这里就是将 Hash Table 当做 HashSet 利用。